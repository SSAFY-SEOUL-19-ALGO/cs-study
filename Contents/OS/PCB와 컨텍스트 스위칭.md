# PCB와 컨텍스트 스위칭

### PCB

**정의**

특정 프로세스의 관리할 필요가 있는 정보를 저장한 운영체제 커널의 자료구조

![PCB구조](https://user-images.githubusercontent.com/96561194/213153503-d72bd667-e644-49cb-8b34-2c585a6dbaaa.png)

**프로세스 생성과 저장**

프로그램이 실행되면 프로세스가 생성되고 프로세스 주소값들에, 스택, 힙 등의 구조를 기반으로 메모리가 할당되고 생성된 프로세스의 메타데이터들이 PCB에 저장되어 관리된다

프로세스가 종료되면 PCB도 삭제된다.

PCB는 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 커널에서 관리된다

메타데이터?

데이터를 구조화 한 데이터

정보를 효율적으로 찾아내서 이용하기 위해 규칙에 따라 내부에 부여되는 데이터 (DB Index)

**역할**

CPU가 프로세스 A 작업을 하던 도중 프로세스 B로 넘어갔을 때 다시 A로 돌아올 수 있게 하기 위한 정보를 보관

### 컨텍스트 스위칭

**정의**

멀티 프로세스 환경안에 cpu가 어떤 하나의 프로세스를 실행하고 있는 상태에서 프로세스에 할당된 시간이 종료되거나 인터럽트에 의해 다음 우선순위 프로세스가 실행되어야할 때 기존 프로세스의 상태 또는 레지스터의 값을 PCB에저장하고, cpu가 다음 프로세스를 실행하도록 새로운 프로세스의 PCB를 교체하는 작업

**인터럽트**

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 장치등에 예외상황이 발생하여 처리가 필요할 경우 CPU에 알려 처리할 수 있도록 하는 것

CPU가 인터럽트를 감지하면, 프로세스가 하던일을 멈추고 인터럽트 백터에서 ISR을 찾아 해당 ISR에 따라 요청에 대한 처리를 수행한다

ISR(인터럽트 서비스 루틴, 인터럽트 핸들러)

인터럽트에 대응하여 특정 기능을 처리하는 기계어 코드 루틴이라고 한다

인터럽트 백터

인터럽트는 다양한 종류가 있고 일어날 수 있는 위치가 정해져있다

이런 다양한 인터럽트를 관리하기 위해 인터럽트의 ISR 을 저장해 놓은 저장소가 인터럽트 백터

**인터럽트 발생과 컨텍스트 스위칭**

1. 키보드 입력 인터럽트 발생
2. 현재 실행중인 프로세스 정보를 PCB에 저장
3. 인터럽트 백터에서 키보드 입력 인터럽트 ISR을 찾음
4. 키보드 인터럽트 처리를 위한 ISR 주소로 변경
5. 키보드 인터럽트 처리
6. 저장된 경로 확인 후 원래 실행중이던 로직 주소로 돌아감

2~6 과정을 컨텍스트 스위칭 이라 한다

**[컨텍스트 스위칭 예시 그림]**

![Untitled](https://user-images.githubusercontent.com/96561194/213153518-80fbebba-8eeb-4acf-85cd-6dc02698506f.png)

프로세스 P0 가 실행하다 멈추고 프로세스 P0의 PCB를 저장한 후 P1을 로드하여 실행

이후 P1의 PCB를 저장한 후 P0를 다시 로드하여 되돌아감

유휴기간

-   위 그림의 idle 처럼 프로세스 바꿀때 CPU가 아무것도 안하고 붕 뜨는 시간이 발생

캐시미스

-   CPU가 데이터를 요청하여 캐시 메모리에 접근 했을 때 해당 데이터가 존재 하지 않아 DRAM에서 정보를 가저와야 하는 경우를 말함
-   컨텍스트 스위칭이 발생할 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시 클리어를 해야하고 이 때 캐시미스가 발생됨

**컨텍스트 스위칭 오버헤드**

컨텍스트 스위칭이 걸린 시간과 + 사용한 메모리 를 뜻함

유휴 기간 + 캐시미스 발생으로 인한 메모리 사용
